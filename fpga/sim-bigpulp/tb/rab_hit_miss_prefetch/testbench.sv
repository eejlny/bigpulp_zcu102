time clk_period = 10ns;    // clock generated by ARM

task tb_wait(input int cycles);
   #(clk_period*cycles);
endtask

module testbench;

  timeunit      1ps;
  timeprecision 1ps;

  logic   ACLK;    // input 
  logic   ARESETn; // input 
    
  logic [31:0] m_axi_sim_araddr  ;
  logic  [1:0] m_axi_sim_arburst ;
  logic  [3:0] m_axi_sim_arcache ;
  logic [13:0] m_axi_sim_arid    ;
  logic  [7:0] m_axi_sim_arlen   ;
  logic        m_axi_sim_arlock  ;
  logic  [2:0] m_axi_sim_arprot  ;
  logic  [3:0] m_axi_sim_arqos   ;
  logic        m_axi_sim_arready ;
  logic  [3:0] m_axi_sim_arregion;
  logic  [2:0] m_axi_sim_arsize  ;
  logic        m_axi_sim_arvalid ;
  logic [31:0] m_axi_sim_awaddr  ;
  logic  [1:0] m_axi_sim_awburst ;
  logic  [3:0] m_axi_sim_awcache ;
  logic [13:0] m_axi_sim_awid    ;
  logic  [7:0] m_axi_sim_awlen   ;
  logic        m_axi_sim_awlock  ;
  logic  [2:0] m_axi_sim_awprot  ;
  logic  [3:0] m_axi_sim_awqos   ;
  logic        m_axi_sim_awready ;
  logic  [3:0] m_axi_sim_awregion;
  logic  [2:0] m_axi_sim_awsize  ;
  logic        m_axi_sim_awvalid ;
  logic [13:0] m_axi_sim_bid     ;
  logic        m_axi_sim_bready  ;
  logic  [1:0] m_axi_sim_bresp   ;
  logic        m_axi_sim_bvalid  ;
  logic [63:0] m_axi_sim_rdata   ;
  logic [13:0] m_axi_sim_rid     ;
  logic        m_axi_sim_rlast   ;
  logic        m_axi_sim_rready  ;
  logic  [1:0] m_axi_sim_rresp   ;
  logic        m_axi_sim_rvalid  ;
  logic [63:0] m_axi_sim_wdata   ;
  logic        m_axi_sim_wlast   ;
  logic        m_axi_sim_wready  ;
  logic  [7:0] m_axi_sim_wstrb   ;
  logic        m_axi_sim_wvalid  ;

  logic        pulp2host_intr    ;

  // PULPEmu SoC
  bigpulp_top DUT (
    .ACLK               ( ACLK               ),
    .ARESETn            ( ARESETn            ),
    
    .tmif_clkl_x1       ( ACLK               ),
    .tmif_resetn        ( ARESETn            ),

    .m_axi_sim_araddr   ( m_axi_sim_araddr   ),
    .m_axi_sim_arburst  ( m_axi_sim_arburst  ),
    .m_axi_sim_arcache  ( m_axi_sim_arcache  ),
    .m_axi_sim_arid     ( m_axi_sim_arid     ),
    .m_axi_sim_arlen    ( m_axi_sim_arlen    ),
    .m_axi_sim_arlock   ( m_axi_sim_arlock   ),
    .m_axi_sim_arprot   ( m_axi_sim_arprot   ),
    .m_axi_sim_arqos    ( m_axi_sim_arqos    ),
    .m_axi_sim_arready  ( m_axi_sim_arready  ),
    .m_axi_sim_arregion ( m_axi_sim_arregion ),
    .m_axi_sim_arsize   ( m_axi_sim_arsize   ),
    .m_axi_sim_arvalid  ( m_axi_sim_arvalid  ),
    .m_axi_sim_awaddr   ( m_axi_sim_awaddr   ),
    .m_axi_sim_awburst  ( m_axi_sim_awburst  ),
    .m_axi_sim_awcache  ( m_axi_sim_awcache  ),
    .m_axi_sim_awid     ( m_axi_sim_awid     ),
    .m_axi_sim_awlen    ( m_axi_sim_awlen    ),
    .m_axi_sim_awlock   ( m_axi_sim_awlock   ),
    .m_axi_sim_awprot   ( m_axi_sim_awprot   ),
    .m_axi_sim_awqos    ( m_axi_sim_awqos    ),
    .m_axi_sim_awready  ( m_axi_sim_awready  ),
    .m_axi_sim_awregion ( m_axi_sim_awregion ),
    .m_axi_sim_awsize   ( m_axi_sim_awsize   ),
    .m_axi_sim_awvalid  ( m_axi_sim_awvalid  ),
    .m_axi_sim_bid      ( m_axi_sim_bid      ),
    .m_axi_sim_bready   ( m_axi_sim_bready   ),
    .m_axi_sim_bresp    ( m_axi_sim_bresp    ),
    .m_axi_sim_bvalid   ( m_axi_sim_bvalid   ),
    .m_axi_sim_rdata    ( m_axi_sim_rdata    ),
    .m_axi_sim_rid      ( m_axi_sim_rid      ),
    .m_axi_sim_rlast    ( m_axi_sim_rlast    ),
    .m_axi_sim_rready   ( m_axi_sim_rready   ),
    .m_axi_sim_rresp    ( m_axi_sim_rresp    ),
    .m_axi_sim_rvalid   ( m_axi_sim_rvalid   ),
    .m_axi_sim_wdata    ( m_axi_sim_wdata    ),
    .m_axi_sim_wlast    ( m_axi_sim_wlast    ),
    .m_axi_sim_wready   ( m_axi_sim_wready   ),
    .m_axi_sim_wstrb    ( m_axi_sim_wstrb    ),
    .m_axi_sim_wvalid   ( m_axi_sim_wvalid   ),
    
    .pulp2host_intr_o   ( pulp2host_intr     )
  );
   
   ///////////////////////////
   //
   // axi4lite verification ip
   //
   ///////////////////////////
   axi4lite_m_if axi_m_if_0(ACLK);
   
   // Master write address channel
   assign m_axi_sim_awaddr   = axi_m_if_0.awaddr ;
   assign m_axi_sim_awvalid  = axi_m_if_0.awvalid;
   assign axi_m_if_0.awready = m_axi_sim_awready ; 
   // Master write data channel
   assign m_axi_sim_wdata    = axi_m_if_0.wdata  ;
   assign m_axi_sim_wstrb    = axi_m_if_0.wstrb  ;
   assign m_axi_sim_wvalid   = axi_m_if_0.wvalid ;
   assign axi_m_if_0.wready  = m_axi_sim_wready  ; 
   // Master write response channel
   assign axi_m_if_0.bresp   = m_axi_sim_bresp   ;
   assign axi_m_if_0.bvalid  = m_axi_sim_bvalid  ;
   assign m_axi_sim_bready   = axi_m_if_0.bready ;
   // Master read address channel
   assign m_axi_sim_araddr   = axi_m_if_0.araddr ;
   assign m_axi_sim_arvalid  = axi_m_if_0.arvalid;
   assign axi_m_if_0.arready = m_axi_sim_arready ;
   // Master read data channel
   assign axi_m_if_0.rdata   = m_axi_sim_rdata  ;
   assign axi_m_if_0.rresp   = m_axi_sim_rresp   ;
   assign axi_m_if_0.rvalid  = m_axi_sim_rvalid  ;
   assign m_axi_sim_rready   = axi_m_if_0.rready ;

   // Master write address channel
   assign m_axi_sim_awid     = '0;       
   assign m_axi_sim_awlen    = 8'h00;   // 1 beat
   assign m_axi_sim_awsize   = 3'b010;  // 4 bytes 
   assign m_axi_sim_awburst  = 2'b00;   // fixed
   assign m_axi_sim_awlock   = 1'b0;    // normal
   assign m_axi_sim_awcache  = 4'b0010; // normal non-cacheable non-bufferable
   assign m_axi_sim_awprot   = 3'b010;  // unpriviledged, non-secure, data
   assign m_axi_sim_awqos    = 4'h0;    // no QoS scheme
   assign m_axi_sim_awregion = '0;
   // Master write data channel
   assign m_axi_sim_wlast   = 1'b1;
   // Master write response channel
   //m_axi_sim_bid
   // Master read address channel
   assign m_axi_sim_arid     = '0;                                                      
   assign m_axi_sim_arlen    = 8'h00;   // 1 beat                                         
   assign m_axi_sim_arsize   = 3'b010;  // 4 bytes                                      
   assign m_axi_sim_arburst  = 2'b00;   // fixed                                        
   assign m_axi_sim_arlock   = 1'b0;    // normal                                       
   assign m_axi_sim_arcache  = 4'b0010; // normal non-cacheable non-bufferable          
   assign m_axi_sim_arprot   = 3'b010;  // unpriviledged, non-secure, data              
   assign m_axi_sim_arqos    = 4'h0;    // no QoS scheme
   assign m_axi_sim_arregion = '0;  
   // Master read data channel
   //m_axi_sim_rid  
   //m_axi_sim_rlast

   import AXI4LITE_M::*; 
   typedef bit [7:0] bit8;
   
   task DataPack64(input longint data, output bit8 pkt[]);
      pkt = new[8];
      pkt[0] = data[7:0];
      pkt[1] = data[15:8];
      pkt[2] = data[23:16];
      pkt[3] = data[31:24];
      pkt[4] = data[39:32];
      pkt[5] = data[47:40];
      pkt[6] = data[55:48];
      pkt[7] = data[63:56];  
   endtask // DataPack

   task DataPack32(input int data, output bit8 pkt[]);
      pkt = new[4];
      pkt[0] = data[7:0];
      pkt[1] = data[15:8];
      pkt[2] = data[23:16];
      pkt[3] = data[31:24];
   endtask // DataPack

   task DataUnpack64(output longint data, input bit8 pkt[]);
      data[7:0]   = pkt[0];
      data[15:8]  = pkt[1];
      data[23:16] = pkt[2];
      data[31:24] = pkt[3];
      data[39:32] = pkt[4];
      data[47:40] = pkt[5];
      data[55:48] = pkt[6];
      data[63:56] = pkt[7];      
   endtask // DataUnpack

  task DataUnpack32(output longint data, input bit8 pkt[]);
      data[7:0]   = pkt[0];
      data[15:8]  = pkt[1];
      data[23:16] = pkt[2];
      data[31:24] = pkt[3];   
   endtask // DataUnpack

   task pulp_write64(AXI4Lite_m_env axi_m, input int address, input longint data);
      bit8 dataIn[], wrRespOut[];
      int unsigned wrRespPtr;
                  
      DataPack64(data,dataIn);
      axi_m.writeData(wrRespPtr, address, dataIn);
      axi_m.getWrResp(wrRespPtr, wrRespOut);
   endtask // pulp_write64
  
   task pulp_write32(AXI4Lite_m_env axi_m, input int address, input int data);
      bit8 dataIn[], wrRespOut[];
      int unsigned wrRespPtr;
                  
      DataPack32(data,dataIn);
      axi_m.writeData(wrRespPtr, address, dataIn);
      axi_m.getWrResp(wrRespPtr, wrRespOut);
   endtask // pulp_write64

   task pulp_read64(AXI4Lite_m_env axi_m, input int address, output longint data);
      bit8 dataOut[], rdRespOut[];
      int unsigned rdPtr;
   
      axi_m.readData(address,8,rdPtr);
      axi_m.getData(rdPtr, dataOut, rdRespOut);
      DataUnpack64(data,dataOut);      
   endtask // pulp_read64

   task pulp_read32(AXI4Lite_m_env axi_m, input int address, output int data);
      bit8 dataOut[], rdRespOut[];
      int unsigned rdPtr;
   
      axi_m.readData(address,4,rdPtr);
      axi_m.getData(rdPtr, dataOut, rdRespOut);
      DataUnpack32(data,dataOut);      
   endtask // pulp_read64
      
   initial
     begin
  bit8 dataIn[], dataOut[], wrRespOut[], wrRespExp[], rdRespOut[], rdRespExp[];
  int unsigned rdPtr, address, wrRespPtr;
  AXI4Lite_m_env axi_m;

  longint unsigned status;
    
  // Create AXI master
  axi_m    = new("AXI master", testbench.axi_m_if_0, 8);
  // Start master vip
  axi_m.startEnv();
  axi_m.setRndDelay(0, 0, 0, 0);
  axi_m.setTimeOut(10000, 100000);
  axi_m.respReportMode(1);
  
  ARESETn = 1'b1; // interfaces, clking
  tb_wait(1);
  ARESETn = 1'b0;
  tb_wait(50);
  ARESETn = 1'b1; // release reset for interfaces, clking
  tb_wait(100);
  
  // // setup clking @ 50 MHz
  // // write configuration: 50 MHz
  // pulp_write64(axi_m, 32'h6E010000 + 12'h200, 32'h04000A01);
  // pulp_write64(axi_m, 32'h6E010000 + 12'h208, 32'h00040014); // 50 MHz
  // 
  // // read status
  // pulp_read64(axi_m, 32'h6E010000 + 4'h4, status);
  // 
  // // confirm config
  // pulp_write64(axi_m, 32'h6E010000 + 12'h25c,4'h7);
  // pulp_write64(axi_m, 32'h6E010000 + 12'h25c,4'h2);

  // wait for lock of clocking_wizard
  wait (DUT.clk_rst_gen_i.clk_manager_i.locked == 1'b1);
    
  // release PULP resets
  pulp_write32(axi_m, 32'h6E000000 + 4'h8, 32'hC0000000); // release GPIO reset for PULP
  tb_wait(100);

  // preload L2 memory
  $readmemh("../../../../slm_files/l2_ram_cut0_lo.slm", DUT.ulpsoc_i.l2_ram_i.l2_mem_i.cut_lo.MEM);
  $readmemh("../../../../slm_files/l2_ram_cut0_hi.slm", DUT.ulpsoc_i.l2_ram_i.l2_mem_i.cut_hi.MEM);
  
  // setup a RAB slice for the mailbox
  pulp_write64(axi_m, 32'h6E030000 + 8'h20, 32'h65120000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h28, 32'h65122000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h30, 32'h1A120000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h38, 32'h7);
  
  // mailbox config, interrupt enable
  pulp_write32(axi_m, 32'h65120000 + 8'h24, 4'h6);

  // setup a RAB slice for the L2
  pulp_write64(axi_m, 32'h6E030000 + 8'h40, 32'h67000000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h48, 32'h67010000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h50, 32'h1C000000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h58, 32'h7);

  // setup a RAB slice for the L1
  pulp_write64(axi_m, 32'h6E030000 + 8'h60, 32'h60000000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h68, 32'h61000000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h70, 32'h10000000);
  pulp_write64(axi_m, 32'h6E030000 + 8'h78, 32'h7);

  // setup a RAB slice for the L3
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h00, 32'h80000000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h08, 32'h88000000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h10, 36'h9F8000000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h18, 32'h7);

  //// setup a RAB slice for loopback to L3
  //pulp_write64(axi_m, 32'h6E030000 + 8'h80, 32'h65110000);
  //pulp_write64(axi_m, 32'h6E030000 + 8'h88, 32'h65120000);
  //pulp_write64(axi_m, 32'h6E030000 + 8'h90, 32'h80000000);
  //pulp_write64(axi_m, 32'h6E030000 + 8'h98, 32'h7);
  //
  //tb_wait(10);
  //pulp_write32(axi_m, 32'h65110000 + 4'h0, 32'hAABBCCDD); // write to L3
  //tb_wait(10);
  //pulp_read32(axi_m, 32'h65110000 + 4'h0, status); // read from L3

  // setup a RAB slice
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h20, 32'hA0000000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h28, 32'hA0001000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h30, 36'h9F8000000);
  pulp_write64(axi_m, 32'h6E0300A0 + 8'h38, 32'h7);

  // setup L2 entries for virtual L3
  // set_num = pfn_virt[4:0] = addr_virt[16:12]
  // off_v = 0x8000 + set_num * 32 * 4 + entry_num * 4
  // off_p = 0x9000 + set_num * 32 * 4 + entry_num * 4

  // addr_virt[32:12] = 0xA0001, addr_virt[16:12] = 0x1
  pulp_write32(axi_m, 32'h6E030000 + 16'h8080, 32'hA00017); // Set 1, Entry 0
  pulp_write32(axi_m, 32'h6E030000 + 16'h9080, 32'h9F8001); 

  // addr_virt[32:12] = 0xA0002, addr_virt[16:12] = 0x2 -> just prepare it, still disable the mapping
  pulp_write32(axi_m, 32'h6E030000 + 16'h8100, 32'hA00026); // Set 2, Entry 0
  pulp_write32(axi_m, 32'h6E030000 + 16'h9100, 32'h9F8002); 

  // start program execution
  pulp_write64(axi_m, 32'h6E000000 + 4'h8, 32'hC0000001);

  // write virtual address to mailbox 
  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0000010); // hit L1
  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0001020); // hit L2

  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0000018); // prefetch hit L1
  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0001028); // prefetch hit L2

  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0001030); // miss L1 / hit L2
  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0002030); // miss L2

  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0001038); // prefetch miss L1 / hit L2
  pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'hA0002038); // prefetch miss L2

  for (int i=0; i<2; i++)
  begin
    // wait for interrupt
    wait (pulp2host_intr == 1'b1);

    // read and clear interrupt register
    status = 0;
    pulp_read32(axi_m, 32'h6E050000, status);

    // handle miss -> activate entry in L2
    pulp_write32(axi_m, 32'h6E030000 + 16'h8100, 32'hA00027);

    // wake up PE 0
    pulp_write32(axi_m, 32'h60200800 + 12'h368, 32'h1);

    // wait for sync
    status = 1;
    while (status) 
      begin
        pulp_read32(axi_m, 32'h65120010, status);
        status = status & 32'h1; // empty
        tb_wait(100);
      end
    pulp_read32(axi_m, 32'h65120008, status);

    if (status == 32'h00000001)// PULP_READY
      $display("PULP_READY received.\n");
    else
      $display("Received %h.\n", status); 

    // again disable the entry in L2
    pulp_write32(axi_m, 32'h6E030000 + 16'h8100, 32'hA00026);

    // read and clear interrupt register
    status = 0;
    pulp_read32(axi_m, 32'h6E050000, status);

    // send sync signal
    pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'h3000); // HOST_DONE
  end

  // wait for mailbox not empty
  status = 1;
  while (status) 
    begin
      pulp_read32(axi_m, 32'h65120010, status);
      status = status & 32'h1; // empty
      tb_wait(500);
    end
  
  // check mailbox content
  pulp_read32(axi_m, 32'h65120008, status);

  if (status == 32'h00000004)// PULP_DONE
    begin
      $display("PULP_DONE received, finish simulation in an instant.\n");
      tb_wait(100);
      $stop;
    end
  else
    $display("Received %h, continue similutaion.\n", status);
  
end

  initial
    begin : clk_gen
      ACLK = 1'b1;
      #(clk_period/2-1);
      while(1) begin
        ACLK = 1'b0;
        #(clk_period/2);
        ACLK = 1'b1;
        #(clk_period/2);
      end
    end

endmodule
