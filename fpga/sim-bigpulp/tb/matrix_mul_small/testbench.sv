time clk_period = 10ns;    // clock generated by ARM

task tb_wait(input int cycles);
   #(clk_period*cycles);
endtask

module testbench;

  timeunit      1ps;
  timeprecision 1ps;

  logic   ACLK;    // input
  logic   ARESETn; // input

  logic [31:0] m_axi_sim_araddr  ;
  logic  [1:0] m_axi_sim_arburst ;
  logic  [3:0] m_axi_sim_arcache ;
  logic [13:0] m_axi_sim_arid    ;
  logic  [7:0] m_axi_sim_arlen   ;
  logic        m_axi_sim_arlock  ;
  logic  [2:0] m_axi_sim_arprot  ;
  logic  [3:0] m_axi_sim_arqos   ;
  logic        m_axi_sim_arready ;
  logic  [3:0] m_axi_sim_arregion;
  logic  [2:0] m_axi_sim_arsize  ;
  logic        m_axi_sim_arvalid ;
  logic [31:0] m_axi_sim_awaddr  ;
  logic  [1:0] m_axi_sim_awburst ;
  logic  [3:0] m_axi_sim_awcache ;
  logic [13:0] m_axi_sim_awid    ;
  logic  [7:0] m_axi_sim_awlen   ;
  logic        m_axi_sim_awlock  ;
  logic  [2:0] m_axi_sim_awprot  ;
  logic  [3:0] m_axi_sim_awqos   ;
  logic        m_axi_sim_awready ;
  logic  [3:0] m_axi_sim_awregion;
  logic  [2:0] m_axi_sim_awsize  ;
  logic        m_axi_sim_awvalid ;
  logic [13:0] m_axi_sim_bid     ;
  logic        m_axi_sim_bready  ;
  logic  [1:0] m_axi_sim_bresp   ;
  logic        m_axi_sim_bvalid  ;
  logic [63:0] m_axi_sim_rdata   ;
  logic [13:0] m_axi_sim_rid     ;
  logic        m_axi_sim_rlast   ;
  logic        m_axi_sim_rready  ;
  logic  [1:0] m_axi_sim_rresp   ;
  logic        m_axi_sim_rvalid  ;
  logic [63:0] m_axi_sim_wdata   ;
  logic        m_axi_sim_wlast   ;
  logic        m_axi_sim_wready  ;
  logic  [7:0] m_axi_sim_wstrb   ;
  logic        m_axi_sim_wvalid  ;

  logic        pulp2host_intr    ;

  // PULPEmu SoC
  bigpulp_top DUT (
    .ACLK               ( ACLK               ),
    .ARESETn            ( ARESETn            ),

    .tmif_clkl_x1       ( ACLK               ),
    .tmif_resetn        ( ARESETn            ),

    .m_axi_sim_araddr   ( m_axi_sim_araddr   ),
    .m_axi_sim_arburst  ( m_axi_sim_arburst  ),
    .m_axi_sim_arcache  ( m_axi_sim_arcache  ),
    .m_axi_sim_arid     ( m_axi_sim_arid     ),
    .m_axi_sim_arlen    ( m_axi_sim_arlen    ),
    .m_axi_sim_arlock   ( m_axi_sim_arlock   ),
    .m_axi_sim_arprot   ( m_axi_sim_arprot   ),
    .m_axi_sim_arqos    ( m_axi_sim_arqos    ),
    .m_axi_sim_arready  ( m_axi_sim_arready  ),
    .m_axi_sim_arregion ( m_axi_sim_arregion ),
    .m_axi_sim_arsize   ( m_axi_sim_arsize   ),
    .m_axi_sim_arvalid  ( m_axi_sim_arvalid  ),
    .m_axi_sim_awaddr   ( m_axi_sim_awaddr   ),
    .m_axi_sim_awburst  ( m_axi_sim_awburst  ),
    .m_axi_sim_awcache  ( m_axi_sim_awcache  ),
    .m_axi_sim_awid     ( m_axi_sim_awid     ),
    .m_axi_sim_awlen    ( m_axi_sim_awlen    ),
    .m_axi_sim_awlock   ( m_axi_sim_awlock   ),
    .m_axi_sim_awprot   ( m_axi_sim_awprot   ),
    .m_axi_sim_awqos    ( m_axi_sim_awqos    ),
    .m_axi_sim_awready  ( m_axi_sim_awready  ),
    .m_axi_sim_awregion ( m_axi_sim_awregion ),
    .m_axi_sim_awsize   ( m_axi_sim_awsize   ),
    .m_axi_sim_awvalid  ( m_axi_sim_awvalid  ),
    .m_axi_sim_bid      ( m_axi_sim_bid      ),
    .m_axi_sim_bready   ( m_axi_sim_bready   ),
    .m_axi_sim_bresp    ( m_axi_sim_bresp    ),
    .m_axi_sim_bvalid   ( m_axi_sim_bvalid   ),
    .m_axi_sim_rdata    ( m_axi_sim_rdata    ),
    .m_axi_sim_rid      ( m_axi_sim_rid      ),
    .m_axi_sim_rlast    ( m_axi_sim_rlast    ),
    .m_axi_sim_rready   ( m_axi_sim_rready   ),
    .m_axi_sim_rresp    ( m_axi_sim_rresp    ),
    .m_axi_sim_rvalid   ( m_axi_sim_rvalid   ),
    .m_axi_sim_wdata    ( m_axi_sim_wdata    ),
    .m_axi_sim_wid      ( '0                 ),
    .m_axi_sim_wlast    ( m_axi_sim_wlast    ),
    .m_axi_sim_wready   ( m_axi_sim_wready   ),
    .m_axi_sim_wstrb    ( m_axi_sim_wstrb    ),
    .m_axi_sim_wvalid   ( m_axi_sim_wvalid   ),

    .pulp2host_intr_o   ( pulp2host_intr     )
  );

  ///////////////////////////
  //
  // axi4lite verification ip
  //
  ///////////////////////////
  axi4lite_m_if axi_m_if_0(ACLK);

  // Master write address channel
  assign m_axi_sim_awaddr   = axi_m_if_0.awaddr ;
  assign m_axi_sim_awvalid  = axi_m_if_0.awvalid;
  assign axi_m_if_0.awready = m_axi_sim_awready ;
  // Master write data channel
  assign m_axi_sim_wdata    = axi_m_if_0.wdata  ;
  assign m_axi_sim_wstrb    = axi_m_if_0.wstrb  ;
  assign m_axi_sim_wvalid   = axi_m_if_0.wvalid ;
  assign axi_m_if_0.wready  = m_axi_sim_wready  ;
  // Master write response channel
  assign axi_m_if_0.bresp   = m_axi_sim_bresp   ;
  assign axi_m_if_0.bvalid  = m_axi_sim_bvalid  ;
  assign m_axi_sim_bready   = axi_m_if_0.bready ;
  // Master read address channel
  assign m_axi_sim_araddr   = axi_m_if_0.araddr ;
  assign m_axi_sim_arvalid  = axi_m_if_0.arvalid;
  assign axi_m_if_0.arready = m_axi_sim_arready ;
  // Master read data channel
  assign axi_m_if_0.rdata   = m_axi_sim_rdata  ;
  assign axi_m_if_0.rresp   = m_axi_sim_rresp   ;
  assign axi_m_if_0.rvalid  = m_axi_sim_rvalid  ;
  assign m_axi_sim_rready   = axi_m_if_0.rready ;

  // Master write address channel
  assign m_axi_sim_awid     = '0;
  assign m_axi_sim_awlen    = 8'h00;   // 1 beat
  assign m_axi_sim_awsize   = 3'b011;  // 8 bytes
  assign m_axi_sim_awburst  = 2'b00;   // fixed
  assign m_axi_sim_awlock   = 1'b0;    // normal
  assign m_axi_sim_awcache  = 4'b0010; // normal non-cacheable non-bufferable
  assign m_axi_sim_awprot   = 3'b010;  // unpriviledged, non-secure, data
  assign m_axi_sim_awqos    = 4'h0;    // no QoS scheme
  assign m_axi_sim_awregion = '0;
  // Master write data channel
  assign m_axi_sim_wlast   = 1'b1;
  // Master write response channel
  //m_axi_sim_bid
  // Master read address channel
  assign m_axi_sim_arid     = '0;
  assign m_axi_sim_arlen    = 8'h00;   // 1 beat
  assign m_axi_sim_arsize   = 3'b010;  // 4 bytes
  assign m_axi_sim_arburst  = 2'b00;   // fixed
  assign m_axi_sim_arlock   = 1'b0;    // normal
  assign m_axi_sim_arcache  = 4'b0010; // normal non-cacheable non-bufferable
  assign m_axi_sim_arprot   = 3'b010;  // unpriviledged, non-secure, data
  assign m_axi_sim_arqos    = 4'h0;    // no QoS scheme
  assign m_axi_sim_arregion = '0;
  // Master read data channel
  //m_axi_sim_rid
  //m_axi_sim_rlast

  import AXI4LITE_M::*;
  typedef bit [7:0] bit8;

  task DataPack64(input longint data, output bit8 pkt[]);
    pkt = new[8];
    pkt[0] = data[7:0];
    pkt[1] = data[15:8];
    pkt[2] = data[23:16];
    pkt[3] = data[31:24];
    pkt[4] = data[39:32];
    pkt[5] = data[47:40];
    pkt[6] = data[55:48];
    pkt[7] = data[63:56];
  endtask // DataPack

  task DataPack32(input int data, output bit8 pkt[]);
    pkt = new[4];
    pkt[0] = data[7:0];
    pkt[1] = data[15:8];
    pkt[2] = data[23:16];
    pkt[3] = data[31:24];
  endtask // DataPack

  task DataUnpack64(output longint data, input bit8 pkt[]);
    data[7:0]   = pkt[0];
    data[15:8]  = pkt[1];
    data[23:16] = pkt[2];
    data[31:24] = pkt[3];
    data[39:32] = pkt[4];
    data[47:40] = pkt[5];
    data[55:48] = pkt[6];
    data[63:56] = pkt[7];
  endtask // DataUnpack

  task DataUnpack32(output longint data, input bit8 pkt[]);
    data[7:0]   = pkt[0];
    data[15:8]  = pkt[1];
    data[23:16] = pkt[2];
    data[31:24] = pkt[3];
  endtask // DataUnpack

  task pulp_write64(AXI4Lite_m_env axi_m, input int address, input longint data);
    bit8 dataIn[], wrRespOut[];
    int unsigned wrRespPtr;

    DataPack64(data,dataIn);
    axi_m.writeData(wrRespPtr, address, dataIn);
    axi_m.getWrResp(wrRespPtr, wrRespOut);
  endtask // pulp_write64

  task pulp_write32(AXI4Lite_m_env axi_m, input int address, input int data);
    bit8 dataIn[], wrRespOut[];
    int unsigned wrRespPtr;

    DataPack32(data,dataIn);
    axi_m.writeData(wrRespPtr, address, dataIn);
    axi_m.getWrResp(wrRespPtr, wrRespOut);
  endtask // pulp_write64

  task pulp_read64(AXI4Lite_m_env axi_m, input int address, output longint data);
    bit8 dataOut[], rdRespOut[];
    int unsigned rdPtr;

    axi_m.readData(address,8,rdPtr);
    axi_m.getData(rdPtr, dataOut, rdRespOut);
    DataUnpack64(data,dataOut);
  endtask // pulp_read64

  task pulp_read32(AXI4Lite_m_env axi_m, input int address, output int data);
    bit8 dataOut[], rdRespOut[];
    int unsigned rdPtr;

    axi_m.readData(address,4,rdPtr);
    axi_m.getData(rdPtr, dataOut, rdRespOut);
    DataUnpack32(data,dataOut);
  endtask // pulp_read64

  initial begin

    bit8 dataIn[], dataOut[], wrRespOut[], wrRespExp[], rdRespOut[], rdRespExp[];
    int unsigned rdPtr, address, wrRespPtr;
    AXI4Lite_m_env axi_m;

    longint unsigned status;

    // Create AXI master
    axi_m    = new("AXI master", testbench.axi_m_if_0, 8);
    // Start master vip
    axi_m.startEnv();
    axi_m.setRndDelay(0, 0, 0, 0);
    axi_m.setTimeOut(10000, 100000);
    axi_m.respReportMode(1);

    ARESETn = 1'b1; // interfaces, clking
    tb_wait(1);
    ARESETn = 1'b0;
    tb_wait(50);
    ARESETn = 1'b1; // release reset for interfaces, clking
    tb_wait(100);

    // wait for lock of clocking_wizard
    wait (DUT.clk_rst_gen_i.clk_manager_i.locked == 1'b1);

    // release PULP resets
    pulp_write32(axi_m, 32'h6E000000 + 4'h8, 32'hC0000000); // release GPIO reset for PULP
    tb_wait(100);

    // preload L2 memory
    $readmemh("../../../../slm_files/l2_ram_cut0_lo.slm", DUT.ulpsoc_i.l2_ram_i.l2_mem_i.cut_lo.MEM);
    $readmemh("../../../../slm_files/l2_ram_cut0_hi.slm", DUT.ulpsoc_i.l2_ram_i.l2_mem_i.cut_hi.MEM);

    // setup a RAB slice for the mailbox
    pulp_write64(axi_m, 32'h6E030000 + 8'h20, 32'h65120000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h28, 32'h65122000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h30, 32'h1A120000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h38, 32'h7);

    // mailbox config, interrupt enable
    pulp_write32(axi_m, 32'h65120000 + 8'h24, 4'h6);

    // setup a RAB slice for the L2
    pulp_write64(axi_m, 32'h6E030000 + 8'h40, 32'h67000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h48, 32'h67010000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h50, 32'h1C000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h58, 32'h7);

    // setup a RAB slice for the L1
    pulp_write64(axi_m, 32'h6E030000 + 8'h60, 32'h60000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h68, 32'h61000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h70, 32'h10000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h78, 32'h7);

/*
    // setup a RAB slice for the stdout
    pulp_write64(axi_m, 32'h6E030000 + 8'h80, 32'h65110000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h88, 32'h65120000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h90, 32'h1A110000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h98, 32'h7);
*/

    // setup a RAB slice for the L3
    pulp_write64(axi_m, 32'h6E0300A0 + 8'h00, 32'h80000000);
    pulp_write64(axi_m, 32'h6E0300A0 + 8'h08, 32'h88000000);
    pulp_write64(axi_m, 32'h6E0300A0 + 8'h10, 36'h9F8000000);
    pulp_write64(axi_m, 32'h6E0300A0 + 8'h18,  4'b1111);

/*
    // setup a RAB slice for loopback to L3
    pulp_write64(axi_m, 32'h6E030000 + 8'h80, 32'h65110000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h88, 32'h65120000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h90, 32'h80000000);
    pulp_write64(axi_m, 32'h6E030000 + 8'h98, 32'h7);

    tb_wait(10);
    pulp_write32(axi_m, 32'h65110000 + 4'h0, 32'hAABBCCDD); // write to L3
    tb_wait(10);
    pulp_read32(axi_m, 32'h65110000 + 4'h0, status); // read from L3
*/

    // Try some writes to the RAB L2 configuration (must be asserted by manual inspection, since L2
    // configuration cannot be read from host).
    pulp_write32(axi_m, 32'h6E038000 + 8'h00, 32'hf111ea57);
    pulp_write32(axi_m, 32'h6E038ffc + 8'h00, 32'h1aaaaa57);
    pulp_write64(axi_m, 32'h6E039000        , 40'hf151caaaa1);

    // start program execution and enable logging
    pulp_write64(axi_m, 32'h6E000000 + 4'h8, 32'hC8000001);

    // write virtual address to mailbox
    pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'h80001C00);
    pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'h80003C00);
    pulp_write32(axi_m, 32'h65120000 + 4'h0, 32'h80005C00);

    // Perform some reads and writes to the AXI Logger BRAMs to verify communication with host.

    pulp_write32(axi_m, 32'h6e100018 + 4'h0, 32'hbadbad00);
    pulp_write32(axi_m, 32'h6e10001c + 4'h0, 32'haefaefae);
    pulp_write32(axi_m, 32'h6e100020 + 4'h0, 32'haaa11100);
    pulp_write32(axi_m, 32'h6e103018 + 4'h0, 32'h22222222);
    pulp_write32(axi_m, 32'h6e10301c + 4'h0, 32'h33333333);
    pulp_write32(axi_m, 32'h6e103020 + 4'h0, 32'h44444444);

    pulp_read32( axi_m, 32'h6e100018 + 4'h0, status);
    assert (status[31:0] == 32'hbadbad00)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e10001c + 4'h0, status);
    assert (status[31:0] == 32'haefaefae)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e100020 + 4'h0, status);
    assert (status[31:0] == 32'haaa11100)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e103018 + 4'h0, status);
    assert (status[31:0] == 32'h22222222)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e10301c + 4'h0, status);
    assert (status[31:0] == 32'h33333333)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e103020 + 4'h0, status);
    assert (status[31:0] == 32'h44444444)
      else $error("AXI Logger: Assertion of R/W from host failed (%x)!", status[31:0]);

    #1ms;

    // Read some logged AXI accesses to verify logged data.

    pulp_read32( axi_m, 32'h6e100000 + 4'h0, status);
    assert (status[31:0] != '0)
      else $error("AXI Logger assertion: Invalid timestamp (%x)!", status[31:0]);
    pulp_read32( axi_m, 32'h6e100004 + 4'h0, status);
    assert (status[7:0] == 8'h1f)
      else $error("AXI Logger assertion: Invalid length (%x)!", status[7:0]);
    pulp_read32( axi_m, 32'h6e100008 + 4'h0, status);
    assert (status[31:0] == 32'h80001c00)
      else $error("AXI Logger assertion: Invalid address (%x)!", status[31:0]);

    pulp_read32( axi_m, 32'h6e10000c + 4'h0, status);
    assert (status[31:0] != '0)
      else $error("AXI Logger assertion: Invalid timestamp (%x)!", status[31:0]);
    pulp_read32( axi_m, 32'h6e100010 + 4'h0, status);
    assert (status[7:0] == 8'h1f)
      else $error("AXI Logger assertion: Invalid length (%x)!", status[7:0]);
    pulp_read32( axi_m, 32'h6e100014 + 4'h0, status);
    assert (status[31:0] == 32'h80001d00)
      else $error("AXI Logger assertion: Invalid address (%x)!", status[31:0]);

/*
    // Read an address that is out of the range of the RAM.  This should cause a (gracefully handled)
    // error.
    pulp_read32( axi_m, 32'h6e1c0000 + 4'h0, status);

    // Write an address that is out of the range of the RAM.  This should cause a (gracefully handled)
    // error.
    pulp_write32(axi_m, 32'h6e1c0004 + 4'h0, 32'h50000bad);
*/

    $display("Testbench completed.");

    // Disable PULP clock and set logger clearing.
    pulp_write32(axi_m, 32'h6e000000 + 4'h8, 32'hB0000000);

    #3ms;

    // Enable PULP clock again.
    pulp_write32(axi_m, 32'h6e000000 + 4'h8, 32'hC0000000);

    // clear mailbox
    for (int i=0; i<500; i++)
      begin
        // wait for mailbox not empty
        status = 1;
        while (status)
          begin
            pulp_read32(axi_m, 32'h65120010, status);
            status = status & 32'h1; // empty
            //tb_wait(500);
            #500us;
          end

      // check mailbox content
      pulp_read32(axi_m, 32'h65120008, status);
    end

/*
  // RAB update on request
  for (int i=0; i<500; i++)
    begin
       // wait for mailbox not empty
       status = 1;
       while (status)
         begin
      pulp_read64(axi_m, 32'h4B000010, status);
      status = status & 32'h1; // empty
      tb_wait(1000);
         end

       // check mailbox content
       pulp_read64(axi_m, 32'h4B000008, status);

       // update the RAB

       // signal ready
       pulp_write64(axi_m, 32'h4B000000 + 4'h0, 32'h1000); // HOST_READY

    end

  // mailbox test
   pulp_write32(axi_m, 32'h65121000 + 4'h0, 32'hFF); // trigger a mailbox interrupt
   tb_wait(10);
   pulp_read32(axi_m,  32'h6E050000 + 4'h0, status); // read axi_intr_reg, clear
   pulp_write32(axi_m, 32'h65120000 + 8'h20, 32'h7); // clear mailbox interrupt
   pulp_read32(axi_m,  32'h65121000 + 4'h8, status);
   pulp_read32(axi_m,  32'h6E050000 + 4'h0, status); // read axi_intr_reg, clear

  // L2 test
  pulp_write32(axi_m, 32'h67000000 + 4'h0, 32'hFFFF5555);
  pulp_read32(axi_m,  32'h67000000 + 4'h0, status);
*/

  end

  initial begin : clk_gen
    ACLK = 1'b1;
    #(clk_period/2-1);
    while(1) begin
      ACLK = 1'b0;
      #(clk_period/2);
      ACLK = 1'b1;
      #(clk_period/2);
    end
  end

endmodule

// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker tw=100
